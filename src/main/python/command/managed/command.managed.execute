#!/usr/bin/env python3
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
# TODO https://stackoverflow.com/questions/1523427/what-is-the-common-header-format-of-python-files
# TODO calculate return code
import subprocess
import sys
import argparse
from pathlib import Path
# TODO FIXME If file not present in path this script should continue.
# TODO listener scripts
def executeCommand(command):
	"""Returns whether the next commands needs to be executed."""
	# TODO Check if command exsists.
	print('Executing ' + ' '.join(command))
	returnCode = subprocess.call(command) # This call raises an error if the command is not found.
	return returnCode == 0
def managedCommandExecution(type, command): # RENAME
	"""If the system does not change significantly and this method is called with the same arguments, the same commands should be executed.
	Keep in mind that the commands that will be executed next in a given stage, are largely determined by the return value of the previously executed commands' return values.
	Otherwise, more resources are used than necessary (i.e. system.update commands that require restarts).
	
	Each executed command should take a finite amount of time, as otherwise managed commands may not be executed correctly.
	(i.e. "system.update": if one update command waits for new updates, it is also blocking other update commands.
	It is preferred that each executed command takes up a small amount of time.
	"""
	executionCounter = 0
	managedCommand = commandAt(command, executionCounter)
	executedSuccessfully = True
	while commandExists(managedCommand[0]):
		executedSuccessfully = executeCommand(managedCommand)
		if type == 'disjunction' and executedSuccessfully:
			return
		if type == 'conjunction' and not executedSuccessfully:
			raise Exception(managedCommand)
		executionCounter+=1
		managedCommand = commandAt(command, executionCounter)
	if not executedSuccessfully:
		raise Exception(managedCommand)
def commandAt(command, number):
	rVal = command.copy()
	rVal[0] = rVal[0] + '.' + str(number)
	return rVal
def commandExists(commandName):
	"""Check whether `name` is on PATH."""
	from distutils.spawn import find_executable
	return find_executable(commandName) is not None
if __name__ == '__main__':
	managedCommandExecution(sys.argv[1], sys.argv[2:]) # The first (0) command is the this script itself.
