#!/usr/bin/env python3
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
# TODO https://stackoverflow.com/questions/1523427/what-is-the-common-header-format-of-python-files
# TODO calculate return code
import subprocess
import sys
import argparse
from pathlib import Path
# TODO FIXME If file not present in path this script should continue.
# TODO listener scripts
def executeCommand(command):
	"""Returns whether the next commands needs to be executed."""
	# TODO Check if command exsists.
	subprocess.call(['echo.debug', 'Executing ' + ' '.join(command)])
	process = subprocess.Popen(command,
		stdout=subprocess.PIPE,
		stderr=subprocess.PIPE)
	process.wait()
	return (process.returncode == 0, process.stdout, process.stderr)
def managedCommandExecution(type, command): # RENAME
	"""If the system does not change significantly and this method is called with the same arguments, the same commands should be executed.
	Keep in mind that the commands that will be executed next in a given stage, are largely determined by the return value of the previously executed commands' return values.
	Otherwise, more resources are used than necessary (i.e. system.update commands that require restarts).
	
	Each executed command should take a finite amount of time, as otherwise managed commands may not be executed correctly.
	(i.e. "system.update": if one update command waits for new updates, it is also blocking other update commands.
	It is preferred that each executed command takes up a small amount of time.
	"""
	executionCounter = 0
	managedCommand = commandAt(command, executionCounter)
	executedSuccessfully = True
	executedCommands = list()
	stdouts = list()
	stderrs = list()
	while commandExists(managedCommand[0]):
		executedSuccessfully, stdout, stderr = executeCommand(managedCommand)
		executedCommands.append(' '.join(managedCommand))
		stderrs.append(stderr)
		stdouts.append(stdout)
		if type == 'disjunction' and executedSuccessfully:
			break
		if type == 'conjunction' and not executedSuccessfully:
			executedSuccessfully = False
			break
		executionCounter+=1
		managedCommand = commandAt(command, executionCounter)
	# TODO Print output during the execution and not afterwards.
	if not executedSuccessfully:
		subprocess.call(['echo.error', 'Could not execute "' + ' '.join(command) + '":'])
		for i in range(0, len(stdouts)):
			# TODO Print command stderr and stdout like if it would be printed without this program.
			print("\nExecuting \"" + executedCommands[i] + '"')
			print("\n" + "   " + "Output:")
			for line in iter(stdouts[i].readline, b''):
				sys.stdout.write("   " + "   " + line.decode(sys.stdout.encoding))
			print("\n" + "   " + "Error Output:")
			for line in iter(stderrs[i].readline, b''):
				sys.stdout.write("   " + "   " + line.decode(sys.stdout.encoding))
		sys.stdout.flush() # If flush is not done, the output of "subprocess.call" is not printed in right order.
		subprocess.call(['echo.error', 'Could not execute "' + ' '.join(command) + '".'])
	else:
		if type == 'disjunction':
			# TODO Print command stderr and stdout like if it would be printed without this program.
			for line in iter(stdouts[-1].readline, b''):
				sys.stdout.write(line.decode(sys.stdout.encoding))
			for line in iter(stderrs[-1].readline, b''):
				sys.stdout.write(line.decode(sys.stdout.encoding))
		else:
			for i in range(0, len(stdouts)):
				# TODO Print command stderr and stdout like if it would be printed without this program.
				for line in iter(stdouts[i].readline, b''):
					sys.stdout.write(line.decode(sys.stdout.encoding))
				for line in iter(stderrs[i].readline, b''):
					sys.stdout.write(line.decode(sys.stdout.encoding))
	sys.stdout.flush()
	return executedSuccessfully
def commandAt(command, number):
	rVal = command.copy()
	rVal[0] = rVal[0] + '.' + str(number)
	return rVal
def commandExists(commandName):
	"""Check whether `name` is on PATH."""
	from distutils.spawn import find_executable
	return find_executable(commandName) is not None
if __name__ == '__main__':
	if managedCommandExecution(sys.argv[1], sys.argv[2:]): # The first (0) command is the this script itself.
		sys.exit(0)
	else:
		sys.exit(1)
