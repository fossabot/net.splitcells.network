#!/usr/bin/env python3
"""
This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at http://mozilla.org/MPL/2.0/.

Objective

Provide a way to create a collection of all file system based repositories of a user, which can be worked on as one.
This is especially useful for decentralized backups or if many projects needs to be organized/used.

Solution

Support processing a tree of repositories (meta repo) and therefore allows working on all repos as one
(i.e. in order to backup everything).

The following tree structure is recommended for the meta repo.
The tree should only have 3 levels of root folders, that are processed by this.
The first level consists of one folder and is the root of the meta repo.

The second level splits the repositories into organisational units like private and public repositories.
A minimal number of second level repositories is recommended in order to ease administration.
If there is no need for such organization the first and second level may be omitted.

The third level contains the roots of all repos containing the actual data.
There should be no repository roots in higher levels, except if it is managed by the backend (i.e. git submodules).
Only third level repositories should be assumed to be fully publicly portable,
because a flat meta repo structure is easiest to support by hosting platforms (i.e. Github, Gitlab, sourcehut etc).

The first and second level repositories are only used in order to organize third level repositories
by the user hosting the first and second level repository.
They are portable, but generally it is harder to migrate them to an other platform.

It is encouraged to use globally unique names for each repo in order to be able to minimize the number of second
level repositories.
Java package name convention is a good start for that.

Objective

The necessary meta info should be stored as simple and portable as possible.
In best case scenario only the relative paths of the sub repos and its possible remote servers has to be stored.

TODO Add switch in order to skip already present folders.
"""

import subprocess
import sys
import argparse
import json
import logging
from os import environ
from pathlib import Path


def execute(relativePath, host, command):
	logging.debug('relativePath: ' + relativePath)
	command = command.replace('$subRepo', '')
	logging.debug('	command: ' + command)
	returnCode = subprocess.call(command, shell='True')
	if returnCode != 0:
		logging.error('	Error processing repository with return code ' + str(returnCode) + '.')
		return False
	return True
def process(relativePath, host, command):
	if not execute(relativePath, host, command):
		return False
	subListPath=Path('./.net.splitcells.os.state.interface.repo/subs.json')
	if subListPath.is_file():
		# TODO Check if "!/.net.splitcells.os.state.interface.repo/" is present in gitignore. If not pr
		with open(subListPath, 'r') as subListFile:
			repoList=json.load(subListFile)
			for subName in repoList['subs'].keys():
				r='repo.process'
				# TODO Do not rely on Bash specific command syntax.
				subRepoScript = 'set -e; mkdir -p ' + subName + '; ' + 'cd ' + subName + ' ; ' + r + " --command='" + command + "' --host=" + host + ' --relative-path=' + relativePath
				subRepoScript = subRepoScript.replace('$subRepo', relativePath + '/' + subName + '/$subRepo')
				logging.debug('subRepoScript: ' + subRepoScript)
				returnCode = subprocess.call(subRepoScript, shell='True')
				if returnCode != 0:
					logging.error('Error processing sub repository with return code ' + str(returnCode) + '.')
					return False
	return True
if __name__ == '__main__':
	if environ.get('log_level') == 'debug':
		logging.basicConfig(level=logging.DEBUG)
	parser = argparse.ArgumentParser(description='TODO')
	parser.add_argument('--relative-path', dest='relativePath', default='./')
	parser.add_argument('--host', dest='host', default="''")
	parser.add_argument('--command', dest='command', required=True)
	parsedArgs = parser.parse_args()
	if not process(parsedArgs.relativePath, parsedArgs.host, parsedArgs.command):
		exit(1)